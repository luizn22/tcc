\chapter{Considerações Finais}

A evolução tecnológica na área de automação e controle de sistemas tem sido um fator determinante no avanço de inúmeras
indústrias e pesquisas científicas.
Ferramentas eficientes para a análise e controle de sistemas dinâmicos são essenciais não apenas para o desenvolvimento
de novas tecnologias, mas também para a otimização de processos existentes.
Em um contexto onde a precisão e a eficiência são cruciais, a necessidade de ferramentas capazes de simplificar e
agilizar estas tarefas torna-se evidente.
A habilidade de modelar e controlar sistemas de maneira eficiente tem implicações diretas na melhoria do desempenho,
segurança e qualidade em diversos setores.

Nesse cenário, este trabalho apresentou uma contribuição significativa ao desenvolver uma biblioteca em Python que
aborda a necessidade de ferramentas aprimoradas para análise e controle de sistemas dinâmicos.
Esta biblioteca, alinhada com as demandas do setor, combina eficácia e facilidade de uso, visando automatizar os
processos de identificação de modelo e aproximação de ganhos de controlador PID para sistemas de controle.
Compatível com diversos ambientes operacionais, a solução desenvolvida é acessível e valiosa tanto para profissionais
da área quanto para estudantes e pesquisadores.
A geral do trabalho de contribuir para um segmento crucial, atendendo às necessidades práticas e educacionais no
campo de automação e controle, foi efetivamente alcançado, destacando-se como um recurso inclusivo e acessível para a
comunidade.

A arquitetura escolhida para a biblioteca, enfatizando a compreensibilidade e a escalabilidade, garante não apenas a
eficácia imediata da ferramenta, mas também a facilidade de expansão futura.
A integração bem-sucedida com a biblioteca de controle para Python existente amplia as possibilidades de uso dos modelos
criados, proporcionando uma versatilidade notável à ferramenta.
Esta característica sublinha a capacidade da biblioteca de se adaptar e ser aplicável em uma variedade de cenários de
controle de sistemas.

Um aspecto fundamental deste trabalho é a concentração na usabilidade da biblioteca, especialmente considerando usuários
com conhecimento limitado em programação Python.
O design da ferramenta, orientado para a facilidade de uso, a torna acessível e prática, oferecendo uma ponte entre o
conhecimento teórico e a aplicação prática no campo de controle e automação.

Os métodos desenvolvidos para a identificação de modelos são intuitivos e requerem um mínimo de intervenção do usuário,
o que simplifica o processo de modelagem.
Além disso, as funções implementadas para a determinação automática ou simplificada de ganhos de controle PID
destacam-se pela sua eficiência, baseando-se nos modelos da planta e nas metas de desempenho do sistema.
Essas características demonstram a praticidade e a aplicabilidade da biblioteca em um contexto real.

A documentação clara e acessível da biblioteca é uma de suas maiores forças.
Não só facilita o uso da ferramenta, mas também serve como um recurso educativo importante, potencializando o impacto
da biblioteca tanto no ensino quanto na prática de controle de sistemas.
Assim, este trabalho não apenas atende às necessidades técnicas dos profissionais da área, mas também contribui
significativamente para a formação e o desenvolvimento de futuros profissionais e pesquisadores em automação e controle.

\section{Sugestões para trabalhos futuros}

Desde a fase inicial de concepção, incluindo o levantamento dos objetivos e o projeto, a biblioteca desenvolvida neste
trabalho foi concebida com a visão de um projeto de CI/CD.
Essa abordagem estratégica visou estabelecer uma base sólida com funcionalidades essenciais, criando um ambiente
propício não apenas para atender às necessidades simples, mas também para facilitar o desenvolvimento de soluções
futuras.
Esse entendimento claro da necessidade de expansibilidade e adaptabilidade foi considerado durante todo o
desenvolvimento do projeto.
Consequentemente, as sugestões para trabalhos futuros, apresentadas nesta seção, são um componente muito importante
do processo de desenvolvimento desde o início.
As sugestões apresentadas representam possibilidades de melhoria factíveis e com vantagens claras.

\subsection{Integração com ferramentas da biblioteca de controle}
A biblioteca de sistemas de controle dispõe de algumas ferramentas para projeto de controlador, nenhuma das quais foi
abordada pela biblioteca desenvolvida neste trabalho.
Visto que os modelos gerados pela biblioteca desenvolvida possuem o objeto principal de análise, a função de
transferência do modelo, e este objeto pertence à biblioteca de controle o uso dessas ferramentas para projeto de
controlador de já é possível.
Contudo, isso depende de um conhecimento mais aprofundado tanto da biblioteca desenvolvida quanto da biblioteca de
controle, e possivelmente conhecimentos em programação com Python.
A integração dessas ferramentas em novas classes de aproximação de controlador pode proporcionar o uso facilitado destas
ferramentas.

As seguintes funções da biblioteca de controle foram consideradas boas opções de integração:
\begin{itemize}
    \item \textbf{place}: esta função pode ser utilizada para alocação de polos do sistema em lugares específicos do plano $s$.
    \item \textbf{lqr}: possibilita o projeto de controladores do tipo Linear-Quadrático Regulador.
    Contudo, envolveria a implementação de um novo objeto de controlador, visto que atualmente apenas controladores PID
    são suportados;
    \item \textbf{sisotool}: por fim, a ferramenta sistool proporciona um ambiente interativo para aplicação do método
    de lugar das raízes;
    A própria biblioteca de controle disponibiliza a função rootlocus\_pid\_designer que tenta possibilitar o projeto
    de controlador PID de forma interativa utilizando a função sisotool por trás dos panos.
\end{itemize}


\subsection{Especialização para casos de ordens mais altas}
Os métodos de identificação implementados neste trabalho se especializam apenas no caso de sistemas de primeira ordem
com atraso, que entregam um objeto de modelo do sistema igualmente especializado.
Para facilitar a implementação de métodos de identificação de modelo e possivelmente de aproximação de ganhos de
controlador PID para sistemas de ordens mais altas, a criação de uma classe especializada em casos clássicos de
segunda ordem, por exemplo, é um passo crucial, que deve ser feito antes de qualquer método que trate de sistemas
de ordens mais altas especializados nesses casos clássicos.

\subsection{Outros métodos de identificação de modelo}\label{subsec:outros-metodos-de-identificacao-de-modelo}
A biblioteca desenvolvida se propõe a implementar formas rápidas e práticas de realizar diveros métodos de identificação
de modelo diferentes, dessa forma se torna evidente a importância da implementação de mais destes métodos.
A seguir nesta sessão serão listadas algumas propostas de métodos que podem ser implementados em melhorias futuras.

\subsubsection{Método de Dorf e Bishop}
Conforme introduzido na sessão 4.3 de \cite{CoelhoIdentificacao}, é possível realizar a manipulação das equações
apresentadas para realizar a identificação de modelos de segunda ordem.
Acompanhado por novas ferramentas de análise da resposta, este método pode ser implementado da mesma forma
que os demais já desenvolvidos.

\subsubsection{Método de Mollenkamp}
Da mesma forma que na seção anterior, o método de Mollenkamp combina a análise do gráfico da resposta a sinal degrau
e o uso de equações pré-determinadas para obtenção do modelo clássico de segunda ordem \cite{CoelhoIdentificacao}.
Caracterizando assim como uma boa opção de melhoria futura.

\subsubsection{Resposta em frequência}
O método de resposta em frequência envolve aplicar um sinal de entrada ao sistema e medir a saída correspondente,
com foco particular na frequência do sinal.
Ele analisa como as diferentes frequências do sinal de entrada afetam a saída do sistema, baseando-se nos
diagramas de’Bode’.
Através da comparação das características de frequência da entrada e da saída, é possível identificar parâmetros do
sistema \cite{CoelhoIdentificacao}.

Este método utiliza um sinal de entrada diferente do sinal degrau implementado na maioria dos outros métodos,
e exige o desenvolvimento novas formas de análise dos dados recebidos.
Contudo, o resultado é um modelo do caso geral, podendo ser de ordens maiores do que primeira ou segunda, uma
introdução importante a biblioteca.

\subsubsection{Resposta impulsiva}
A identificação via resposta impulsiva, conforme descrito em \cite{CoelhoIdentificacao}, é um método de identificação
de sistemas que utiliza a resposta do sistema a um impulso unitário para estimar seus parâmetros.
Neste método, um sinal de impulso é aplicado à entrada do sistema, e a saída resultante, que é a resposta impulsiva, é
observada e analisada.
O resultado obtido é a resposta do sistema no domínio da frequência para sistemas discretos.

Da mesma forma que o método de resposta em frequência, este método exitem o deselvolvimento de novas ferramentas
com o adicional da conversão de seu resultado para o domínio da frequência para sistemas contínuos, para que seu
resultado seja compatível com as outras implementações da biblioteca.


\subsection{Outros métodos de aproximação de ganhos de controlador}
Da mesma forma que na sessão \ref{subsec:outros-metodos-de-identificacao-de-modelo}, esta sessão lista propostas
de novos métodos de aproximação de controlador que podem ser implementadas como melhorias futuras.

\subsubsection{Método de Shamsuzzoha e Skogestad}
O método de Setpoint Overshoot proposto por Shamsuzzoha e Skogestad para a afinação de controladores PID baseia-se em
experimentos de resposta a mudanças de setpoint em laço fechado, sem necessidade de realizar a identificação de um
modelo do sistema \cite{skoge}.
O processo começa com a realização de um experimento de resposta a um degrau de entrada usando um controlador apenas
proporcional.
A partir dos dados do experimento, especialmente o primeiro pico de ultrapassagem (overshoot) e o tempo para alcançá-lo,
o método estabelece fórmulas diretas para calcular os parâmetros do controlador, como o ganho proporcional e o tempo
integral.

Este método se torna um pouco diferente de outros métodos de aproximação de controlador, visto que não recebe um modelo
pronto, de forma que faria mais sentido cria-lo como um método em separado, que retorne apenas os ganhos encontrados.
Esses ganhos podem ser utilizados para instanciar um objeto da classe Controller juntamente a um objeto de modelo.
Possibilitando assim a plotagem da resposta a sinal degrau.

\subsubsection{Sintonia Baseada em Minimização da Integral do Erro}
O método de Sintonia Baseada em Minimização da Integral do Erro tem o objetivo de minimizar o erro de controle ao
longo do tempo.
Este método foca em otimizar critérios como a Integral do Valor Absoluto do Erro (IAE) ou a Integral Ponderada pelo
Tempo do Valor Absoluto do Erro (ITAE), que medem o erro acumulado de maneiras distintas, sendo a segunda mais severa
com erros prolongado.
Este método se aplica ao modelo clássico de primeira ordem da equação \eqref{eq:firstordertf}, e os calculos de ganho
de controlador são feitos através de fórmulas espessíficas, que utilizam os parâmetros $K$, $\tau$ e $\theta$ da equação
\eqref{eq:firstordertf} e além de constantes tabeladas, calculadas a partir das integrais IAE e ITAE.
De forma que pode ser implementado juntamente aos outros métodos de tabela para este caso de modelo clássico
implementados \cite{apostpidsint}.

\subsubsection{Sintonia pelo método do IMC}
Este é mais um método de tabela introduzido em \cite{apostpidsint}.
Ele possui fórmulas tabeladas para o caso da equação \eqref{eq:firstordertf} e pode ser implementado sem grandes
mudanças no projeto.

\subsubsection{Otimização por enxame de partículas baseado em gradiente}
A partir do método de otimização por enxame de partículas baseado em gradiente, explorado em \cite{gpsopt} e uma função
de pontuação que receba métricas de desempenho do sistema, como tempo de acomodação e sobre sinal, fornecida pelo usuário,
é possível realizar a aproximação de ganhos de controlador PID por otimização.
Os valores dos ganhos do controlador podem ser tomados como as coordenadas das partículas, e a função, onde devem ser
buscados os mínimos locais, é dada pela obtenção do valor da pontuação, calculado pela função fornecida pelo
usuário, com base nas métricas de desempenho, obtidas pela análise da resposta a sinal degrau, para cada partícula.
Este método pode ser aplicado para qualquer tipo de modelo, contudo seu custo operacional pode variar conforme o caso.

\subsection{Análise de resposta a outros sinais de entrada}
Atualmente os métodos de plotagem de gráficos de resposta dos sistemas se especializam apenas em respostas a sinal
degrau.
A biblioteca de controle do Python, utilizada para gerar os dados de resposta, também suporta a simulação da resposta
de funções de transferência a outros sinais de entrada, de modo que não seria muito complexo possibilitar que o mesmo
fosse feito ao realizar plotagens pela biblioteca desenvolvida.

\subsection{Documentação em inglês}
A documentação de código da biblioteca desenvolvida nesse trabalho foi criada e disponibilizada apenas em português.
Isso limita o alcance do projeto, dado o alcance da lingua inglesa em comparação, propõe-se a tradução e
disponibilização da documentação em inglês também.
A ferramenta de documentação utilizada, sphinx, tem suporte a documentações em múltiplos idiomas, de modo que essa
melhoria não exigiria grandes refatorações do projeto.

\subsection{Automatização do versionamento}
Atualmente o versionamento da biblioteca exige diversas alterações manuais nos arquivos de configuração do projeto para
cada nova versão liberada, o que pode causar não idealidades na entrega de novas versões.
Algumas automações podem ser implementadas para facilitar esse processo, como a orientação das versões a tags do git,
por exemplo.
Um caso onde essas automações foram implementadas de forma compreensível é o da própria biblioteca de controle para o
Python utilizada neste trabalho, o código dela pode servir de exemplo para a melhoria proposta.
